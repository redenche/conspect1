4  xtkjdtrf dblbvj jcnfkbcm njkmrj nt rjnjhst [jnzn htfkmyj pfybvfnmcz

предисловие 
 при устанновке в окружение командной строки добавляется исполняемый файл с именем .go исполняемый файл go предоставляет в ваше распоряжение различные комманы
в числе которых:
go build имя файла - компилирует файлы с исходнм кодом в двоичные файлы.
go run имя файла-  компилирует и запускает программу без сохранений в используеомо файле. - удобна
go fmt имя файла - перефарматирует исходные файлы с использование стандартного форматирования.
go version - выводит текущую версию go.



 2 ГЛАВА
условные команды и циклы
Вызов методов
в языке go определяют методы:
функции, связынные со значением определенного типа\

в пакете .time определенн тип Time, представляющий дату под год. месяц и день и время час минута чекунды и т.д.. Каждое значение в 
time.Time содержит Year, Который возвращает год.

var now time.Time =time.Now()
var Year int = now.Year()
func main(){
fmt.Println(Year)
метод  Year возвращает целое значение года, которое выводится программой.

подстрока - часть строки
например слово в предложении
пакет strings содержит тип replacer, который ищет подстроку в строке и заменяет каждое вхождение этой подстроки в другой строке. 
Следущий код заменяет каждый символ 1 в строке символом 9:

функция string.NewReplacer получает аргументы - заменяет строку ("1") на ("9") - и возвращает значение strings.Replacer.
когда мы передаем строку, в которой выполнена указанная замена
package main

import (
	"fmt"
"strings"
)


func main(){
broken := "71 liceum"
replace := strings.NewReplacer("1", "9")
fixed := replace.Replace(broken)
fmt.Println(fixed)
}


синтаксис вызовов методов очень похож на синтаксис вызовов пакетов
если функция упоминавшееся ранее упомяналось ранее принадлежавшемуся пакету то методы принадлежат к коректному значению это значение устнанавливается с лева от точки.




















